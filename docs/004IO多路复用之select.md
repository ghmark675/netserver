# 前言

在003中，我们使用了多进程/线程的方式解决多个客户端连接的问题，但实际上这种方式性能很低

有一种优化的思路是，在当前进程监视某几个socket时，服务端进程完全可以让出CPU（陷入阻塞），在某些事件发生（比如新的客户端连接，读、写）时，唤醒进程进行处理

这就是`I/O`多路复用中`select`在做的事情，很简单吧

代码写起来更简单，因为已经有库函数`select()`帮我们实现了所有的底层细节，我们只需要使用它即可

# select()流程

将要监控的socket告知操作系统`-->`操作系统将进程加入到所有socket等待队列中`-->`有至少一个socket有事件`-->`操作系统唤醒进程`-->`操作系统将进程从每个socket等待队列中移除

> 如何告知操作系统要监控哪些socket？

使用位图的形式，需要监控的socket指定位置为1，不需要监控就是0。位图数据结构：`fd_set`

将位图传给select后，有事件发生的socket会被置为1

具体的使用，还是`man select`或者上网搜吧

当然，代码最好也进行一下封装，就不单开一节进行封装了

# 读事件
select可以监测：

1. 已连接队列中有已经准备好的socket（有新的客户端连上来了）
2. 接收缓存中有数据可以读（对端发送的报文已到达）
3. tcp连接已断开（对端调用close()函数关闭了连接）

# 写事件

select可以检测：
1. 发送缓冲区没有满，可以写入数据（可以向对端发送报文）
